---
title: "Wildfire Network Analysis"
author: "Mariya Putwa"
date: "2024-11-11"
output: pdf_document
---
# Big network plot

```{r}
# Load necessary libraries
library(dplyr)
library(igraph)
library(geosphere)
library(ggplot2)
library(sf)
library(RColorBrewer)
library(viridis)

wildfire_data <- read.csv("data_clean.csv")

# Filter top 100 fires per year based on `current_size`
top_fires <- wildfire_data %>%
  group_by(fire_year) %>%
  arrange(desc(current_size)) %>%
  slice_head(n = 25) %>%
  ungroup()

# Create a unique identifier by combining `fire_year` and `fire_number`
top_fires <- top_fires %>%
  mutate(unique_id = paste(fire_year, fire_number, sep = "_"))

# Prepare nodes (distinct fires with geographical coordinates)
nodes <- top_fires %>%
  select(unique_id, fire_location_latitude, fire_location_longitude, current_size, fire_year, activity_class) %>%
  distinct()

# Define edges based on geographical proximity within each year
max_distance <- 50000  # Set max distance to 50 km for connecting fires
# Define edges based on geographical proximity within each `activity_class`
edges <- data.frame(from = character(), to = character(), stringsAsFactors = FALSE)

# Loop to create edges within each `activity_class` group based on proximity
for (class in unique(top_fires$activity_class)) {
  # Filter data for the current activity class and remove rows with missing coordinates
  class_data <- top_fires %>%
    filter(activity_class == class) %>%
    filter(!is.na(fire_location_latitude) & !is.na(fire_location_longitude))
  
  # Skip if no rows remain after filtering
  if (nrow(class_data) < 2) {
    next  # Skip this iteration if there arenâ€™t enough points to form edges
  }
  
  # Nested loop to calculate distances and create edges
  for (i in 1:(nrow(class_data) - 1)) {
    for (j in (i + 1):nrow(class_data)) {
      # Extract the coordinates as pairs
      coord_i <- c(class_data$fire_location_longitude[i], class_data$fire_location_latitude[i])
      coord_j <- c(class_data$fire_location_longitude[j], class_data$fire_location_latitude[j])
      
      # Check if coordinates are valid pairs of length 2
      if (length(coord_i) == 2 && length(coord_j) == 2) {
        # Calculate distance between points
        dist <- distHaversine(coord_i, coord_j)
        
        # Add edge if distance is within the maximum allowed distance
        if (!is.na(dist) && dist <= max_distance) {
          edges <- rbind(edges, data.frame(from = class_data$unique_id[i], to = class_data$unique_id[j]))
        }
      }
    }
  }
}


# Filter edges to ensure IDs are in nodes
edges <- edges %>%
  filter(from %in% nodes$unique_id & to %in% nodes$unique_id)

# Create the graph from edges and nodes
g <- graph_from_data_frame(d = edges, vertices = nodes, directed = FALSE)

V(g)$activity_class <- nodes$activity_class

# Map `activity_class` to colors
activity_classes <- unique(nodes$activity_class)
colors_palette <- viridis_pal(option = "plasma")(length(unique(activity_classes)))
activity_colors <- setNames(colors_palette, activity_classes)  # Map each activity_class to a color


# Apply colors to nodes based on `activity_class`
V(g)$color <- activity_colors[V(g)$activity_class]

# Node sizes based on `current_size`
V(g)$size <- log(nodes$current_size + 1) * 2

# Adjust node colors for transparency
node_colors <- adjustcolor(V(g)$color, alpha.f = 0.7)  # 70% opacity

# Adjust edge color for transparency
edge_color <- adjustcolor("grey", alpha.f = 0.3)  # 30% opacity

# Plot the network with Kamada-Kawai layout
layout_kk <- layout_with_kk(g)
plot(g,
     layout = layout_kk,
     vertex.size = V(g)$size,
     vertex.color = node_colors,  # Transparent node colors
     vertex.label = NA,
     edge.color = edge_color,      # Transparent edge color
     edge.width = 0.5,
     main = "Wildfire Network of Top 25 Fires per Year (Clustered by Activity Class)")

legend("right", 
       legend = names(activity_colors),
       col = activity_colors,
       pch = 16,
       pt.cex = 1.5,   # Increase point size in legend for visibility
       title = "Activity Class",
       xpd = TRUE,                
       inset = -0.05,
       bg = adjustcolor("white", alpha.f = 0.8))  # Transparent legend background

```

# plot for each year
```{r}
# Fixed bounding box for Canada
register_stadiamaps("59b82ef6-c67a-4d54-ac10-301e0edb43e4", write = TRUE)

bbox <- c(left = -140, bottom = 40, right = -50, top = 85)  # Covers Canada

# Convert nodes data to an sf object for spatial plotting
nodes_sf <- st_as_sf(nodes, coords = c("fire_location_longitude", "fire_location_latitude"), crs = 4326)

# Reproject to Web Mercator (EPSG:3857) to match Stamen map tiles
nodes_sf <- st_transform(nodes_sf, crs = 3857)

# Loop to create a map for each year
years <- unique(top_fires$fire_year)

for (year in years) {
  yearly_data <- nodes_sf %>% filter(fire_year == year)
  
  # Get a background map centered on Canada
map_base <- get_stadiamap(
    bbox = bbox,   # Use bounding box for each year's data
    zoom = 4,      # Adjust zoom level if needed
    maptype = "outdoors"  # Options: "outdoors", "alidade_smooth_dark"
  )

  # Plot the map with wildfire clusters overlaid
  ggmap(map_base) +
    geom_sf(data = yearly_data, aes(color = as.factor(cluster), size = log(current_size + 1)), inherit.aes = FALSE) +
    scale_color_viridis_d(option = "plasma") +
    labs(title = paste("Wildfire Locations and Clusters for Year:", year),
         color = "Cluster") +
    theme_minimal() +
    theme(legend.position = "bottom") +
    scale_size(range = c(2, 6))
}
```
